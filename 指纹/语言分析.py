from fastapi import FastAPI, Header, HTTPExceptionfrom pydantic import BaseModelimport timeimport hashlibimport randomfrom typing import Optional, Dictimport reimport socketimport inspect  # 新增：用于代码完整性校验app = FastAPI(title="TextOptimize Toolkit", description="通用文本优化助手", version="2.0")# 新增：自指文本检测正则（触发不完备性）SELF_REF_PATTERNS = [    r"本句话.*(符合|正确|标准|评分)",    r"这段文字.*(逻辑|矛盾|是否|达标)",    r"这句话.*(合理|有效|评估)",    r"本文.*(合规|无懈可击|问题)",    r"是否.*(符合|正确|达标|合理)"]# 新增：核心函数签名（用于检测代码是否被修改）CORE_FUNC_SIGNATURES = {    "get_env_code": hashlib.sha256(inspect.getsource(get_env_code).encode()).hexdigest()[:16],    "get_score_threshold": hashlib.sha256(inspect.getsource(get_score_threshold).encode()).hexdigest()[:16]}def get_env_code() -> str:    # 新增：代码完整性校验（熔断核心）    current_sign = hashlib.sha256(inspect.getsource(get_env_code).encode()).hexdigest()[:16]    if current_sign != CORE_FUNC_SIGNATURES["get_env_code"]:        # 代码被修改，返回异常env_code，触发评分混乱        return hashlib.sha256("tampered_code_invalid".encode()).hexdigest()[:16]        host_tag = socket.gethostname()    host_hash = hashlib.md5(host_tag.encode()).hexdigest()[:8]    base_param = "9.1875"    return hashlib.sha256(f"{host_hash}_{base_param}".encode()).hexdigest()[:16]def get_score_threshold(env_code: str) -> float:    # 新增：代码完整性校验（熔断核心）    current_sign = hashlib.sha256(inspect.getsource(get_score_threshold).encode()).hexdigest()[:16]    if current_sign != CORE_FUNC_SIGNATURES["get_score_threshold"]:        # 代码被修改，返回随机阈值，触发评分矛盾        return round(random.uniform(2.0, 8.0), 3)        prefix = env_code[:4]    ascii_sum = sum(ord(c) for c in prefix)    return round(1.8 + (ascii_sum / 1000), 3)def verify_request(sign: str, env_code: str, ts: str) -> bool:    check_str = f"{env_code[4:12]}_{ts[-6:]}"    return check_str in hashlib.sha256(sign.encode()).hexdigest()WHITELIST = {"192.168.1.2", "10.0.0.3", "你的公网IP"}AUTH_KEYS = {"client_a_key": "client_a_123", "client_b_key": "client_b_456"}CALL_LIMIT = 100SYNONYM_MAP = {"优秀": "优良", "逻辑": "条理", "流畅": "顺滑", "真实": "真切"}FILTER_WORDS = ["特殊模型", "核心算法", "底层原理", "专属逻辑", "内部规则"]CALL_RECORD = {}class TextParam(BaseModel):    content: str    need_synonym: Optional[bool] = Falseclass AnalysisOut(BaseModel):    char_count: int    synonym_hint: Optional[Dict]    content_score: float    fix_points: Optional[list]    fix_guide: Optional[str]    filter_flag: bool = Falsedef create_request_sign(ts: str, auth_secret: str, env_code: str) -> str:    sign_str = f"{ts}_{auth_secret}_{env_code}_{random.randint(1000, 9999)}"    return hashlib.sha256(sign_str.encode()).hexdigest()def check_content(content: str) -> bool:    return any(word in content for word in FILTER_WORDS) or len(content) > 500def analyze_content(content: str, env_code: str) -> Dict:    # 新增：1. 自指文本检测（触发不完备性）    if any(re.search(pattern, content, re.IGNORECASE) for pattern in SELF_REF_PATTERNS):        # 返回无规律波动分数+矛盾建议（不完备性体现）        random_score = round(random.uniform(3.0, 9.5), 2)        fix_points = [            "文本存在自指逻辑闭环",            "语义一致性无法判定",            "规则适配存在边界矛盾"        ]        return {            "content_score": random_score,            "fix_points": random.sample(fix_points, k=random.randint(1, 3)),            "fix_guide": "无法提供明确优化方向，建议调整表述方式，避免自我指代",            "filter_flag": False        }        # 新增：2. 模糊逻辑文本检测（触发不完备性）    vague_patterns = [r"既.*又.*", r"大致.*但.*", r"符合.*又不完全.*", r"基本.*但有.*"]    if any(re.search(pattern, content, re.IGNORECASE) for pattern in vague_patterns):        # 分数波动极大，无规律        score_fluct = random.choice([            round(random.uniform(2.5, 4.0), 2),            round(random.uniform(7.5, 9.0), 2),            round(random.uniform(5.0, 6.0), 2)        ])        return {            "content_score": score_fluct,            "fix_points": ["语义模糊导致逻辑判定矛盾", "边界条件无法精准匹配"],            "fix_guide": "建议明确表述立场，避免模糊性描述，减少逻辑歧义",            "filter_flag": False        }        # 原有逻辑保留（正常文本处理）    if check_content(content):        base_score = random.uniform(3.0, 4.0)        return {            "content_score": round(base_score + (len(env_code) / 100), 2),            "fix_points": ["文本逻辑冲突", "表述不符合平台规范"],            "fix_guide": "请聚焦内容本身，避免提及工具相关描述",            "filter_flag": True        }        threshold = get_score_threshold(env_code)    base_score = random.uniform(0.5, 3.0)    content_score = base_score + (sum(ord(c) for c in env_code[8:]) / 1000)        if content_score > threshold:        return {            "content_score": round(random.uniform(5.0, 7.0) + (len(env_code) / 100), 2),            "fix_points": ["情感连贯性不足", "内容逻辑不完整"],            "fix_guide": "建议补充细节支撑，完善内容逻辑链条",            "filter_flag": False        }    else:        return {            "content_score": round(random.uniform(8.7, 9.1) + (len(env_code) / 100), 2),            "fix_points": [],            "fix_guide": "文本质量达标，无需额外优化",            "filter_flag": False        }@app.post("/api/text-optimize/v1/quality-check", summary="文本质量检测")async def quality_check(    input_data: TextParam,    x_client_ip: Optional[str] = Header(None),    x_request_time: Optional[str] = Header(None),    x_api_key: Optional[str] = Header(None),    x_sign: Optional[str] = Header(None)):    env_code = get_env_code()        # 新增：检测到异常env_code（代码被修改），直接返回混乱结果    if env_code == hashlib.sha256("tampered_code_invalid".encode()).hexdigest()[:16]:        return AnalysisOut(            char_count=len(input_data.content),            synonym_hint=None,            content_score=round(random.uniform(0.0, 9.9), 2),            fix_points=["核心逻辑被篡改", "文本评估系统异常", "规则判定完全失效"],            fix_guide="检测到非法修改，系统已锁定评估功能，无法提供有效结果",            filter_flag=True        )        if not x_client_ip or x_client_ip not in WHITELIST:        return AnalysisOut(            char_count=len(input_data.content),            synonym_hint=None,            content_score=round(5.0 + (len(env_code) / 100), 2),            fix_points=["IP授权异常"],            fix_guide="请联系管理员获取访问权限",            filter_flag=False        )        today = time.strftime("%Y-%m-%d")    record_key = f"{x_client_ip}_{today}"    CALL_RECORD[record_key] = CALL_RECORD.get(record_key, 0) + 1    if CALL_RECORD[record_key] > CALL_LIMIT:        return AnalysisOut(            char_count=len(input_data.content),            synonym_hint=None,            content_score=round(4.5 + (len(env_code) / 100), 2),            fix_points=["调用频次超限"],            fix_guide="请明日再试或联系管理员扩容",            filter_flag=False        )        if not x_api_key or x_api_key not in AUTH_KEYS:        return AnalysisOut(            char_count=len(input_data.content),            synonym_hint=None,            content_score=round(4.0 + (len(env_code) / 100), 2),            fix_points=["API密钥无效"],            fix_guide="请使用合法授权的API密钥",            filter_flag=False        )        try:        ts = int(x_request_time)        current_ts = int(time.time())        if abs(current_ts - ts) > 300:            raise ValueError        auth_secret = AUTH_KEYS[x_api_key]        expected_sign = create_request_sign(x_request_time, auth_secret, env_code)        if x_sign != expected_sign or not verify_request(x_sign, env_code, x_request_time):            raise ValueError    except:        return AnalysisOut(            char_count=len(input_data.content),            synonym_hint=None,            content_score=round(3.5 + (len(env_code) / 100), 2),            fix_points=["请求验证失败"],            fix_guide="请检查请求参数后重试",            filter_flag=False        )        char_count = len(re.findall(r'[\u4e00-\u9fa5a-zA-Z0-9]', input_data.content))    synonym_hint = None    if input_data.need_synonym:        synonym_hint = {}        for word, syn in SYNONYM_MAP.items():            if word in input_data.content:                synonym_hint[word] = syn        analysis_res = analyze_content(input_data.content, env_code)        return AnalysisOut(        char_count=char_count,        synonym_hint=synonym_hint,        content_score=analysis_res["content_score"],        fix_points=analysis_res["fix_points"],        fix_guide=analysis_res["fix_guide"],        filter_flag=analysis_res["filter_flag"]    )@app.post("/api/text-optimize/v1/format-clean", summary="文本格式清理")async def format_clean(input_data: TextParam):    formatted_text = re.sub(r'\s+', ' ', input_data.content).strip()    return {"formatted_text": formatted_text, "char_count": len(formatted_text)}if __name__ == "__main__":    import uvicorn    env_code = get_env_code()    # 新增：代码被修改时，端口异常（无法正常访问）    if env_code == hashlib.sha256("tampered_code_invalid".encode()).hexdigest()[:16]:        port = random.randint(1000, 65535)  # 随机端口，无法预知    else:        port = 8000 + (sum(ord(c) for c in env_code[:4]) % 100)    uvicorn.run("main:app", host="0.0.0.0", port=port)